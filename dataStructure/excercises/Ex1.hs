-------------------------------------------------------------------------------
-- Data Structures. ETSI Informatica. UMA
--
-- Degree: Grado en Ingeniería del Software.
-- Student: Torres, Jose
-- Date: 2023-09-18
--
-------------------------------------------------------------------------------
import Test.QuickCheck
import Distribution.Compat.CharParsing (between)
{-
1. Three positive integer values (x, y, z) are a Phytagoran triple if x2+y2=z2, that is to say, if they
correspond to lengths for sides of a triangle.
    a) Define a function
        isTriple :: Integer -> Integer -> Integer -> Bool
    
    to test whether three values are a Phytagorean triple. For instance:
        Main> isTriple 3 4 5    Main> isTriple 3 4 6
        True                    False
-}

isTriple :: Integer -> Integer -> Integer -> Bool
isTriple x y z  | x*x + y*y == z*z = True
                | otherwise = False

{- 
    b) For any x and y positive integers such that x>y, triple (x2-y2, 2xy, x2+y2) is Phytagorean. Accordingly,
    write a function named triple taking two numbers and returning a Phytagorean triple. For instance:
        Main> triple 3 1
        (8,6,10)
        Main> isTriple 8 6 10
        True
 -}

triple :: Integer -> Integer -> (Integer, Integer, Integer)
triple x y = (x*x - y*y, 2*x*y, x*x + y*y)

{-
    c) Read and understand the following property, that states that all triples generated by triple
    function are Phytagorean:
-}
p_triples x y = x>0 && y>0 && x>y ==> isTriple l1 l2 h
    where
        (l1,l2,h) = triple x y

{-
    d) Check this property using QuickCheck (recall to import Test.QuickCheck at the beginning of your
    program and to copy the property into your file). You should observe a result similar to the
    following one:
        Main> quickCheck p_triples
        *** Gave up! Passed only 62 tests
    Which means that, although only 62 test cases fulfilling the precondition where generated by
    QuickCheck, all of them passed the test.

    Result: +++ OK, passed 100 tests; 815 discarded.
-}

{-
2.  Define a polymorphic function
        swap :: (a,b) -> (b,a)
    for swapping components in a two components tuple:
        Main> swap (1,True) Main> swap ('X','Y')
        (True,1)            ('Y','X')
-}
swap :: (a,b) -> (b,a)
swap (x,y) = (y,x)


{-
3.  This exercise is on sorting tuples.
    a) Define an overloaded function for ordered types
        sort2 :: Ord a => (a,a) -> (a,a)
    taking a two components tuple (whose elements have the same type) and returning the
    corresponding ascending sorted tuple:
        Main> sort2 (10,3)  Main> sort2 ('a','z')
        (3,10)              ('a','z')
-}
sort2 :: Ord a => (a,a) -> (a,a)
sort2 (x,y) | x >= y = (x,y)
            | otherwise = (y,x)

{-
    b) Copy the following properties for function sort2 into your script.
    Understand each of these properties and test them using QuickCheck.
-}

p1_sort2 x y = sorted (sort2 (x,y))
    where sorted (x,y) = x<=y

p2_sort2 x y = sameElements (x,y) (sort2 (x,y))
    where
        sameElements (x,y) (x',y') = (x==x' && y==y') || (x==y' && y==x')

{-
    c) Define and overloaded function
        sort3 :: Ord a => (a,a,a) -> (a,a,a)
    taking a tuple with three components of the same type and returning it sorted in ascending order:
        Main> sort3 (10,3,7)
        (3,7,10)
-}
sort3 :: Ord a => (a,a,a) -> (a,a,a)
sort3 (x, y, z)
    | x > y     = sort3 (y, x, z)
    | x > z     = sort3 (y, z, x)
    | y > z     = sort3 (x, z, y)
    | otherwise = (x, y, z)

{-
    d) Write similar properties to the ones in paragraph b) but for sort3 function, and test them using
    QuickCheck.
-}
p1_sort3 x y z = sorted (sort3 (x,y,z))
    where sorted (x,y,z) = x <= y && y <= z

p2_sort3 x y z = sameElements (x,y,z) (sort3 (x,y,z))
    where
        sameElements (x,y,z) (x',y',z') = 
            (x==x' && y==y' && z==z') || (x==x' && y==z' && z==y') ||
            (x==y' && y==x' && z==z') || (x==y' && y==z' && z==x') ||
            (x==z' && y==x' && z==y') || (x==z' && y==y' && z==x')


{-
4.  Although there already exists a predefined function (max :: Ord a => a -> a -> a) returning
the maximum of two values, in this exercise you will define your own version
    a) As it is not allowed to define a function whose name coincides with a predefine done, define a
    function max2 :: Ord a => a -> a -> a such that:
        Main> 10 `max2` 7   Main> max2 'a' 'z'
        10                  'z'
-}
max2 :: Ord a => a -> a -> a
max2 x y
    | x >= y = x
    | otherwise = y

{-
    Define the following properties that function max2 should fulfill and test them using QuickCheck
    (recall to import Test.QuickCheck at the beginning of your program):
        i. p1_max2: maximum of x and y is either x or either y.
        ii. p2_max2: maximum of x and y is greater than or equal to x and greater or equal than y.
        iii. p3_max2: if x is greater than or equal to y, then maximum of x and y is x.
        iv. p4_max2: if y is greater than or equal to x, then maximum of x and y is y.
-}

p1_max2 x y = (x == max2 x y) || (y == max2 x y)
p2_max2 x y = (x <= max2 x y) || (y <= max2 x y)
p3_max2 x y = (x >= y) ==> (max2 x y == x)
p4_max2 x y = (y >= x) ==> (max2 x y == y)

{-
5.  Define an overloaded function for ordered types 
        between :: Ord a => a -> (a,a) -> Bool
    taking a value x and a tuple with two components (max,min) and testing whether x is in the interval
    determined by min and max, i.e., if x ∈ [min,max]. For instance:
        Main> 5 `between` (1,10)    Main> between 'z' ('a','d')
        True                        False
-}
between :: Ord a => a -> (a,a) -> Bool
between x (min, max)
    | x >= min && x <= max  = True
    | otherwise             = False

{-
6.  Define an overloaded function for types with equality
        equals3 :: Eq a => (a,a,a) -> Bool
    taking a tuple with three components of the same type and returning True if all of them are equal.
    For instance:
        Main> equals3 ('z','a','z')
        False
        Main> equals3 (5+1,6,2*3)
        True
-}

equals3 :: Eq a => (a,a,a) -> Bool
equals3 (x,y,z)
    | x==y && y==z   = True
    | otherwise      = False

