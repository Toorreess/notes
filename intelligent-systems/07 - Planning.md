# 1. Introduction
Planning is *devising a plan of action to achieve an agentâ€™s goals*.

- The agent considers a little part of the world. This part is in an **initial state**.
- The agent can change the state of the world by executing some **actions**.
- A **goal** is a condition that the agent wants to be satisfied by the state of the world.
- In order to do this, the agent must execute a sequence of actions such that the state of the world finally satisfies the goal. That sequence of actions is a **plan**.

> given a certain initial state, a certain goal and a set of possible actions, generate a plan such that the resulting state satisfies the goal.

## 1.1 First-Order Logic Atoms
In first-order logic atoms are no longer atomic: an atom is composed of:
- *A predicate symbol*
- *Arguments* that are *terms*. Terms can be *constants* or *variables*.

**For example:** `Hates(Ann,Bob)` to represent the information "Ann hates Bob".
1. For every object, a *constant* (by convention, the first letter is always uppercase).
2. For every attribute of an object or relation between objects, a *predicate* (by convention, the first letter is always uppercase).

`Hates(x,y)` uses *variables* (by convention, the first letter of a variable is lowercase).

## 1.2 Quantifiers
`x` and `y` in `Hates(x,y)` are undetermined elements of the class. So we can write an **existencial quantifier** $\exists y \ Hates(x,y)$ and an **universal quantifier** $\forall y \ Hates(x,y)$.

# 2. A Language for Plans
## 2.1 Representation of planning problems
We consider a language called **PDDL** (*Planning Domain Definition Language*), which describes all the things we need to define a search problem:
- **States**.
	- *Initial state*.
	- *States generated by applying actions*.
	- *Goal state*.
- **Actions**.
	- Deciding if an action is available in a state.
	- Compute the state resulting from applying an action.

For states we use a First-Order Language with constants and predicates.

Each state is represented by the *conjunction* of atoms, i.e., disjunction and denial is not allowed in the definition of states.
## 2.2 Assumptions
Based on database semantics.
- Assumption of a closed world: if it is not said, it is false.
- Assumption of unique names: two constants do not refer to the same object.

## 2.3 Actions
We are not interested in specific actions, but in general ones; actually representing a scheme of action. The use of variables is allowed to describe the action. 

We must offer a precondition (to decide) and an effect (to compute).
- The precondition is a conjunction of atoms, no negations are allowed.
- The effect is a conjunction of literals, negations are allowed.

The action scheme consists of:
- Action name
- Variables used
- Precondition
- Effect

**Example with planes:**
- Name & variables: $Fly(p, from,to)$
- Precondition: $Plane(p) \wedge Airport(from) \wedge Airport(to) \wedge At(p, from)$
- Effect: $At(p,to)\wedge \neg At(p,from)$

## 2.4 Plans
- A **planning domain** is a set of action schemes.
- A **planning problem** within a planning domain is defined by adding an initial state $S$ and a goal $G$.
- A **solution plan** for a planning problem is a sequence of actions and states $S_0, A_1, S_1, \dots, A_n, S_n$ such that
	1. Every action $A_i$ in the sequence is an instance of an action of the domain.
	2. $S_0) is the initial state.
	3. $A_i (i>0)$ is applicable to $S_{i-1}$
	4. $S_i (i>0$) is the result of applying $A_i$ to $S_{i-1}$
	5. $S_n$ satisfies the goal $G$.

Informally, we also call *solution plan* just to the corresponding sequence of actions $A_1,\dots,A_n$
