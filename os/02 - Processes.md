# Concept of Process
## Definition
An isolated environment to execute a code:
- Independent of the real HW:
	- The process uses services (syscalls) to hide real hardware implementation.
	- CPU, RAM and I/O are shared between processes without interferences.
- Isolated:
	- From the HW (can't do I/O operations).
	- From the kernel memory (can't access kernel mem).
	- From other processes (can't access other proc mem).

>Corollaries:
> - Any executable program can run as if it was running alone on the processor
> - Two instances of the same program can run simultaneously without interferences: each one will have its own and private resources.

# Components of a Process
## Memory Map of a Process
The process memory is assigned by the kernel to load the contents of the executable file during process creation. This is divided in several segments of different types (instructions, variables, stack). The process memory map:

**Code segment (static size, RO access)**
- Contains the machine code generated by the compiler (project files + libraries). 
- It size is fixed.
- It has read-only access (*except with virus infections*).

**Data segment (static size, RW access)**
- This is the memory space reserved by the compiler to store global variables. 
- It’s size if fixed. 
- It has read/write access.

**Heap segment (dynamic size, RW access)**
- This is the space used by the dynamic memory (malloc/free). The size changes depends on the execution of the program. 
- It grows and shrinks dynamically. 
- Read/write access.

**Stack segment (dynamic size, RW access)**
- This is the space for the CPU stack. The size varies with the execution of the program and the type of algorithms. 
- It grows dynamically. 
- It has read/write access.

## Execution context of a process
The execution context is the whole state of the CPU before executing a machine instruction. The result of one instruction depends on the history of changes that all the previous instructions have done to the CPU state.
> The context of a running process is the state of the CPU itself (it changes with every instruction executed).

If we want to interrupt a process at a given point and continue it later, the context must be preserved intact on memory.
> Interrupt handler functions use the stack to save and restore context.

Contents of context:
- **Program Counter** (*PC*): address of next instruction.
- **Processor Flags**: status of the previous instruction.
- All user **registers** visible in user mode.
- **Stack Pointer value after saving context**.

*Stack pointer value can't be saved on stack*

## Process Resources
The kernel must remember the state of the resources altered by a process through system calls:
- The process **can’t be trusted** to “remember” the state of resources to avoid **security breaches**.
- The kernel must “remember” the state of system resources inside *protected kernel data structures*.
	- Open files descriptors, open network connection descriptors (TCP, UDP).
	- Semaphores, message queues, shared memory regions.

Examples:
**Files** (table of open file descriptors):
- Each existing process has its table of opened file descriptor inside the kernel.
- The result of `read(f, buffer, size);`
- Depends on previously successful execution of `int f=open(“f.dat”, mode);`
- The *file descriptor id* is only an integer to indicate the kernel the file descriptor we want to reference.

**Network connections** (stored in the same table of descriptors)
```C
int s=socket(AF_INET, SOCK_STREAM, 0);
bind(s, &addr, len);
connect(s ,&dstaddr, len);
write(s, buff, size);
```

# Process Context Switching
(see the slides)

# Process States
